# Copyright 2026 Achronus
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Persistent XLA compilation cache setup and live progress bar helper."""

import contextlib
import pathlib
import threading

import jax
from tqdm import tqdm

DEFAULT_CACHE_DIR = pathlib.Path.home() / ".cache" / "atarax" / "xla_cache"

_cache_configured = False


def setup_cache(cache_dir: pathlib.Path | str | None = DEFAULT_CACHE_DIR) -> None:
    """
    Configure a persistent XLA compilation cache.

    Idempotent â€” safe to call multiple times; only the first call takes effect.

    Parameters
    ----------
    cache_dir : Path | str | None
        Directory where compiled XLA kernels are stored.  Defaults to
        `~/.cache/atari-jax/xla_cache`. Pass `None` to disable caching.
    """
    global _cache_configured

    if cache_dir is None or _cache_configured:
        return

    path = pathlib.Path(cache_dir)
    path.mkdir(parents=True, exist_ok=True)

    jax.config.update("jax_compilation_cache_dir", str(path))
    jax.config.update("jax_persistent_cache_min_compile_time_secs", 0.0)
    jax.config.update("jax_persistent_cache_min_entry_size_bytes", -1)
    jax.config.update("jax_persistent_cache_enable_xla_caches", "all")
    _cache_configured = True


@contextlib.contextmanager
def _live_bar(bar: tqdm, interval: float = 0.1):
    """
    Refresh *bar* from a background thread while the body executes.

    tqdm only redraws when `update()` is called, so without this the elapsed
    timer appears frozen during a long blocking operation such as XLA
    compilation.

    Parameters
    ----------
    bar : tqdm
        The progress bar instance to refresh.
    interval : float (optional)
        Seconds between refreshes. Default is `0.1`.
    """
    stop = threading.Event()

    def _spin():
        while not stop.is_set():
            bar.refresh()
            stop.wait(interval)

    t = threading.Thread(target=_spin, daemon=True)
    t.start()
    try:
        yield
    finally:
        stop.set()
        t.join()
